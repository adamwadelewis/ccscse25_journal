\section{Project InfuseAI}
\label{lbl:method}
%-------------------------------------
Research has shown that participatory or project-based learning methods can level the playing field for different types of students.  For example, computer science and engineering have historically been less accessible for female and underrepresented minority students. As a result, these students are underrepresented in most computer science and engineering departments in this country.  A shift to a learning environment that values interactivity, cooperation, and collaboration can result in a broader range of students feeling more comfortable and, by extension, can lead to greater persistence and success~\cite{weston2019predicting,loes2022effect,eaton2024artificial}. 
%[4, 5, 23]. 
Furthermore, studies have shown that the choice of context or problem domain of assignments and examples used in class can have a dramatic impact on student motivation and in turn on the quality of their learning~\cite{dabrowski2018motivation,lovellette2024contextualization}.  A problem domain a student relates to and finds relevant leads to deeper understanding and hence a smoother transfer to other domains~\cite{dixon2012transfer}.  Studies have also shown that female undergraduate computer science students tend to be more interested in real applications of computing as opposed to computing for its own sake~\cite{weston2019predicting,wu2024diversifying}. %[1, 25].
Our projects involve machine learning systems and span a wide range of application areas that instructors can choose from. 
%-------------------------------

%We build on a successful existing NSF-funded project, 
We build on an earlier NSF-funded project,
that explored the project-based approach to teaching introductory artificial intelligence courses using the unifying theme of Machine Learning, a Computational Thinking technique that has been influential in many disciplines, as noted by many~\cite{mitchell2006discipline}.  This was a multi-institutional effort that engaged a community of 20 scholars from a broad range of universities working together on the creation of curricular material, and on the development, implementation, and testing of 24 student projects.  Each project involved the development of a machine learning system in a specific application. The applications included network security, recommender systems, game playing, intelligent agents, computational chemistry, robotics, conversational systems, cryptography, web document classification, vision, data integration in databases, bio-informatics, pattern recognition, %data mining, 
and others.  
%-------------------------------------
%Machine learning is inherently connected with the AI core topics and provides methodology and technology to enhance real-world applications within many of these topics.  Machine learning also provides a bridge between AI technology and modern software engineering. As Mitchell~\cite{mitchell2006discipline} points out, machine learning is now considered as a technology for both software development (especially suitable for difficult-to-program applications or for customizing software) and building intelligent software.  Machine Learning is also important in a more general context as part of the basic IT skills the CS students must master. It is listed as number one in several blog articles~\cite{comptiaIT,365datascience}.
%--------------------------------------
%-------------------------------------
%``Top IT Skills in Demand in 2024''~\cite{comptiaIT,365datascience}. 
%\textcolor{blue}{need more recent reference}
%--------------------------------------
%Our work aims at engaging scholars from the same community of scholars to work on the development of project InfuseAI for the presentation of core computational topics based on a scaffolded approach to scale down the earlier developed AI-themed projects.  on adapting the earlier projects to be used in introductory computer science courses, CS1 and CS2. 
%Our proposed model involves the development and testing of an adaptable framework for the presentation of core computational topics based on a scaffolded approach to scale down AI projects.
%-------------------------------------

%Our work aims to engage scholars from the same academic community to collaboratively develop 
%Project InfuseAI, which 
Project InfuseAI focuses on presenting core computational topics through a scaffolded approach. The goal is to adapt and scale down previously developed AI-themed projects for use in introductory computer science courses, specifically CS1 and CS2.
Through the design and implementation of systems that enhance commonly deployed applications, our innovative model for teaching introductory computing provides a simple and elegant means to communicate the power of the core ideas of computing in a manner that engages students in experiential education. We believe that these project-based curricular materials will stimulate student interest early in their studies, have a dramatic impact on their motivation, enhance their learning experiences, and motivate further study in computing.
%-------------------------
%\textcolor{blue}{
Guided by the results of our experiences with the prior work and by the positive results of its assessment, we use a scaffolded approach to scale down the AI projects and adapt a component of each for use in the introductory computer science courses.
%}
%----------------------------------------
%Guided by the results of our experiences with the prior work and by the positive results of its assessment, we use a scaffolded approach to scale down the AI projects and adapt them for use in the introductory computer science courses.

%--------------------------------------
\subsection{Objectives}
%------------------------------
The difficulties mentioned earlier associated with the introductory computer science courses, combined with the fact that %artificial intelligence 
AI provides a rich set of applications that can be used to stimulate student interest and promote greater participation, are the motivating factors for this project.  Our work uses the iterative design-implement-test approach. The specific objectives are: %listed below:
%------------------
%\begin{itemize}
    %\item 
    (i) Enhance the student learning experience in the introductory computer science courses by applying and relating fundamental Computational Thinking concepts of algorithmic thinking, data representation, and computational efficiency to real-world problems and to a broad range of challenges and opportunities;
    %-----------------------
    %\item 
    (ii) Increase student interest and motivation to study computer science early in their studies by providing a framework for the presentation of core computing concepts that emphasizes the strong connection between computer science and other fields;
    %--------------------
    %\item 
    (iii) Highlight the rich set of applications that can be used to stimulate student interest and promote greater participation, motivating them to pursue further study in computing;
    %--------------------
    %\item 
    (iv) Prepare students for the AI workforce;
    %--------------------
    %\item 
    (v) Assess the effectiveness of our approach in achieving our goals. 
%\end{itemize}

%-------------------------------------
\subsection{Outcomes}
%-------------------------------------
%These objectives will be accomplished
%\textcolor{blue}{ }
These objectives are accomplished through the development, implementation, and testing of a suite of adaptable and self-contained, hands-on, team-oriented laboratory projects that can be closely integrated into introductory courses that would supplement introductory computer science texts. The specific project outcomes are:
%\begin{itemize}
    %\item 
    (i) A sustainable and adaptable framework that allows students to learn and apply core computing concepts to a broad range of real-world problems; 
    %\item 
    (ii) A lab manual that includes curricular material and supporting resources for the introductory computer science courses;
    %\item 
    (iii) An instructor’s manual that provides a sample syllabus to go with each project and guidance for the adoption and adaptation of this curricular material.  The instructor manual will include sample solutions as well as supporting material such as code and documentation;
    %\item 
    (iv) An assessment report of the effectiveness of the model.
%\end{itemize}

%-------------------------------------
\subsection{Sample projects}
%-------------------------------------
%In this section, we describe two sample projects that can be used in the introductory computer science courses, CS1/CS2. 
%These courses, which are mandatory for computer science and computer engineering majors, are also commonly taken by students from various other disciplines, including science, mathematics, and business.
In this section, we present two sample projects for CS1/CS2, which are mandatory for computer science and computer engineering majors, and are commonly taken by students from other fields such as science, math, and business.

%--------------------------
%These courses which are required of computer science
%-------------------------------
%The course two introductory computer science courses which are required of computer science 
%-------------------------------
%and computer engineering majors are also taken by science, math, business, and students from other disciplines. 
%-----------------------------
%In this section, we describe two sample projects to be used in CS 1/CS2 courses.
%--------------------------------------
\subsubsection{Social Network Analysis}
%------------------------------------
%----------------------------------
\begin{figure}
\centering
  \includegraphics[width=0.6\linewidth]{figs/fig12.pdf}
  \caption{Example graph for power iteration}
  \label{fig:graph}
\end{figure}
%-------------------------------------
%This programming project requires students to write an interactive Java program for creating and editing graphs. In addition to the basic GUI features, students have to implement the internal graph representation and an algorithm for computing the prestige score of the graph nodes. Thus, the project provides a framework for applying basic programming concepts in a topical application setting. The computer science concepts that fall in this framework are GUI, event-driven programming, computer graphics (such as Euclidean space, points, segments, and distance), and data structures (trees and graphs). To complete the project, students need to apply fundamental computational mathematics concepts such as matrix computation, power iteration, and convergence. The algorithm that students implement for computing the prestige score is from social network analysis and web page ranking, areas that support two important practical applications of computer science, information retrieval and web search.  Below is a summary of the project given to students.
%--------short version---------------
In this project, students %will 
develop an interactive Java program to create and edit graphs. Along with implementing a basic Graphical User Interface (GUI), students must design the internal graph structure and compute node prestige scores using a ranking algorithm. This project reinforces core computer science concepts such as event-driven programming, GUI design, Euclidean geometry (points, distances, segments), and data structures like trees and graphs. Students will also apply key computational math skills, including matrix operations and iterative methods. The prestige score algorithm draws from real-world applications in social network analysis and web search, offering practical relevance and hands-on experience with fundamental programming and algorithmic techniques.
Below is a summary of the project given to students.

%------------------------------------
\noindent \textbf{Project Description:}
Write a graph drawing program in Java. Use the program discussed in class (Graph.java, Lines.java, Dots.java) and make the following changes and additions: 
%\begin{itemize}
    %\item 
    (i) Add an arrowhead at the end of the edges (two short lines starting at the endpoint). You may use ideas and code from Lines.java;
    %--------------------
    %\item %Add two more buttons - Create and Delete. When the Create button is pressed, new nodes and edges can be added. After pressing the Delete button, nodes and edges can be removed by clicking on them. Add a label indicating the current mode (Create or Delete). The third button, "Print adjacency matrix" should work as in the original program (no changes or additions). For detecting a click over (or close to) a node or an edge use the distance between points and the distance from a point to a line (see Dots.java and Lines.java).
     %--------short version--------------
    (ii) Add two new buttons: Create and Delete. When Create is pressed, allow the user to add nodes and edges by clicking. When Delete is pressed, allow the user to remove nodes and edges by clicking on them.
    Include a label that clearly shows the current mode (Create or Delete).
    The third button, ``Print adjacency matrix'', should function as in the original version. To detect clicks near nodes or edges, use distance calculations—such as point-to-point and point-to-line distance (refer to Dots.java and Lines.java);
  %--------------------------
    %\item 
    (iii) Add a button that, when pressed, computes and prints the prestige score of the graph nodes. Use the power iteration algorithm described below.
% \end{itemize}
%===========================
%--------------------------------
\begin{algorithm}[h]
    \SetAlgorithmName{Pseudocode}{}{}
    \SetKwRepeat{Do}{do}{while}
    \DontPrintSemicolon 
    %\KwIn{Some inputs}
    %\KwOut{The ouput}
    $P \gets P_0$ \;
    \Do{$\Vert P-Q\Vert > \epsilon$}{
      $Q \gets P$ \;
      $P \gets A^TQ$ \;
      $P \gets \frac{P}{\Vert P\Vert}$}
    %\Return{the solution}\;
    \caption{Computing prestige score using power iteration}
    \label{algo:power}
\end{algorithm}
%-----------------------------
\textit{Computing prestige score by power iteration:}
The Pseudocode for computing prestige score by power iteration is shown in Pseudocode~\ref{algo:power}. 
The matrix $A$ is the adjacency matrix that the program creates for the current graph. $P$ and $Q$ are vectors, where each component of $P$ represents the prestige score of the corresponding graph node. The norm used in computing $\Vert P \Vert$ and $\Vert P-Q \Vert$ is the Euclidean length of the vector and $\epsilon$ is a small constant that controls the convergence of the algorithm. $P_0$ can be initialized with all 1s. Figure~\ref{fig:graph} shows an example graph and the matrices used in the equations with values obtained by power iteration.
%-------------------------------
% \begin{figure}
%   \includegraphics[width=\linewidth,height=5cm]{figs/fig11.pdf}
%   \caption{Pseudocode for computing prestige score}
%   \label{fig:pseudocode}
% \end{figure}
%--------------------------------
%The program below implements the power iteration algorithm for the graph shown in Figure~\ref{fig:graph} and computes the prestige vector $P$.  To complete the project you need to extend this program to work not only with $3\times3$ matrices but also with matrices and vectors of any size.
%-----------------------------------
You are given a program implementing the power iteration algorithm for the graph shown in Figure~\ref{fig:graph}. To complete the project, you need to extend this program to work not only with $3\times3$ matrices but also with matrices and vectors of any size.

%=====================================
%\begin{minted}[linenos=false, breaklines, breakafter=d, fontsize=\tiny]{java}[linewidth=\columnwidth,breaklines=true]
%-------------------------------------
%\begin{lstlisting}
%\captionof{listing}{My C-Code}
%\label{code:c-code}
%---------------------------------------
%====================================
% \begin{minted}[linenos=false, breaklines, breakafter=d, fontsize=\small]{java}
% /* Solving matrix equation lambda x P = A x P by Power Iteration
%             |p1|   | 0 0 1 |   |p1|
%    lambda x |p2| = | 1 0 0 | x |p2|
%             |p3|   | 1 1 0 |   |p3|
% */
% public class PowerIteration
% {   
%     static final double epsilon = 0.01;
%     static double p1=1, p2=1, p3=1, q1, q2, q3, lambda;
    
%     public static void main (String[] args)
%     {
%         do {
%             q1 = p1;
%             q2 = p2;
%             q3 = p3;
%             p1 = 0*q1 + 0*q2 + 1*q3;
%             p2 = 1*q1 + 0*q2 + 0*q3;
%             p3 = 1*q1 + 1*q2 + 0*q3;
%             lambda = norm(p1,p2,p3);
%             p1 = p1/lambda;
%             p2 = p2/lambda;
%             p3 = p3/lambda;
%             System.out.println(p1+"\t"+p2+"\t"+p3+"\t"+lambda);            
%         } while (norm(p1-q1,p2-q2,p3-q3)>epsilon);
%    }
%     private static double norm (double x, double y, double z) 
%     { 
%         return Math.sqrt(x*x+y*y+z*z);   
%     }
%}
% \end{minted}
% \caption{File Line.java}
% \label{lst:example}
% \end{lstlisting}
%=========NEW VERSION==================
% \begin{lstlisting}[language=Python,caption={My code example}]
% /* Solving matrix equation lambda x P = A x P by Power Iteration
%             |p1|   | 0 0 1 |   |p1|
%    lambda x |p2| = | 1 0 0 | x |p2|
%             |p3|   | 1 1 0 |   |p3|
% */
% public class PowerIteration
% {   
%     static final double epsilon = 0.01;
%     static double p1=1, p2=1, p3=1, q1, q2, q3, lambda;
    
%     public static void main (String[] args)
%     {
%         do {
%             q1 = p1;
%             q2 = p2;
%             q3 = p3;
%             p1 = 0*q1 + 0*q2 + 1*q3;
%             p2 = 1*q1 + 0*q2 + 0*q3;
%             p3 = 1*q1 + 1*q2 + 0*q3;
%             lambda = norm(p1,p2,p3);
%             p1 = p1/lambda;
%             p2 = p2/lambda;
%             p3 = p3/lambda;
%             System.out.println(p1+"\t"+p2+"\t"+p3+"\t"+lambda);            
%         } while (norm(p1-q1,p2-q2,p3-q3)>epsilon);
%    }
%     private static double norm (double x, double y, double z) 
%     { 
%         return Math.sqrt(x*x+y*y+z*z);   
%     }
% }
% \end{lstlisting}
%---------------------------------
%-----------DOCUMENTATION------------
%\noindent\textit{Documentation:} 
%Run your program and make sure it compiles without errors and works as described above. Then add your name in the beginning of the code as a comment. Also, add comments to explain the classes and methods used. Note that comments and the way you format your program will be graded too.
%-----------short version-----------
%Make sure your program compiles and runs correctly as described in the requirements. At the top of your code, add a comment with your name. Include clear, meaningful comments for each class and method to explain what they do. Keep your code well-organized and easy to read. Both comments and formatting will count toward your grade.

%----------SUBMISSION------------------------
%\noindent\textit{Submission:} 
%Submit the following in a single Word or PDF file:\begin{enumerate}[label=(\roman*)] 
%\item the source code (.java) of all classes used, 
%\item a screen copy of the BlueJ Programs window showing all classes used, 
%\item a screen copy showing an example run of your program.
%\end{enumerate}
%---------------------------------
%Submit the following in a single Word or PDF file: (i) the source code (.java) of all classes used; (ii) a screen copy of the BlueJ Programs window showing all classes used; (iii) a screen copy showing an example run of your program.
%--------------------------------------

%----------------------------------
\subsubsection{Non-GUI based Adventure Game}
%----------------------------------
%This project provides a hands-on framework to apply object-oriented design principles, allowing students to model entities (\textit{e.g.}, players, enemies) using classes and objects. Moreover, they will utilize essential Java concepts such as variables, data types, control structures, and input handling. Beyond core programming, students will also explore basic AI algorithms, like prediction models, and integrate them into the gameplay, enhancing both the challenge and interactivity of the experience. Thus, this project offers a comprehensive opportunity to strengthen the understanding of Java programming, object-oriented design, and AI integration.
%------------short version-------------
This project provides a practical framework for applying object-oriented programming (OOP) design by modeling entities (e.g., players, enemies) through classes and objects. Students will reinforce core Java concepts, including variables, data types, control structures, and input handling, while also exploring basic AI techniques, such as prediction models, to enhance gameplay. The project thus provides a comprehensive learning experience in Java programming and AI integration.

%-----------------------------------
\noindent \textbf{Project Description:}
Design and write code in Java to implement a non-GUI-based interactive Adventure game. Some of the key features of the game are the following: 
%\begin{itemize}
%\item

\noindent\textit{World navigation:} 
    %The player will navigate a fantasy world by randomly encountering various enemies. These random encounters will initiate combat, requiring players to engage with the enemies by choosing certain actions such as attacking and proceeding on their journey. 
    %-----------short version-----------
    The player navigates a fantasy world where random enemy encounters occur. Each encounter starts a simple combat sequence, and the player chooses actions like ``attack'' to defeat enemies and continue their journey.
    %--------------------------------
%\item 

\noindent\textit{Combat System:} 
    %Player and enemies each have key statuses such as health, attack power, and defense power. Only the Player will contain an additional ability, which is having a certain number of health potions to restore his/her health.  Combat involves turns where both the player and the enemy alternate between various actions. During the player's turn, he/she can choose to attack or use items such as health potions. During the enemy’s turn, it can choose to only attack or defend first and then attack. The outcome of each action is influenced by attack and defense stats, with successful hits reducing the opponent’s health by a random amount from the attack power. The game must continuously track various aspects of the player's status, including health, number of health potions, and whether the player is alive. Moreover, during combat, the system should maintain real-time updates of the enemy’s health and stats. 
    %----------short version----------
    Both the player and enemies have key attributes such as health, attack power, and defense. The player also has a limited number of health potions to restore health. Combat is turn-based: on each turn, the player can choose to attack or use a potion, while the enemy can attack or defend before attacking. Damage is calculated based on attack and defense values, reducing health accordingly. The game continuously tracks the player's health, potion count, and alive status, while also updating the enemy’s stats in real time during combat.
    %--------------------------------

    %\item 
\noindent\textit{Game Flow:} 
    %The game starts with the player entering his/her name and setting off for an exploration of the fantasy world. As the player navigates, random encounters with different enemies can occur, triggering combat. The battle continues till either the enemy or the player dies, \textit{i.e.} the health reaches zero. The player can choose to attack the enemy to damage its health or use a health potion to restore his/her health. The game progresses in this way until the player either chooses to end their journey or their health reaches zero, resulting in the game being over.
    %---------short version-----------
    The game begins with the player entering a name and starting their journey through a fantasy world. As they explore, random enemy encounters trigger turn-based combat. Battles continue until either the player's or the enemy’s health drops to zero. The player can attack or use a health potion to recover. The game ends when the player’s health reaches zero or they choose to stop their journey.
    %-------------------------------
%\end{itemize}
%---------------------------------------
Incorporate the following features into the adventure game using AI to enhance the enemy’s capability. 

\noindent\textit{Player’s Move Prediction:}
%The game will employ a simple classification model such as Naive Bayes to predict the player's next action—whether to attack or use health potions to heal—based on the player’s previous decisions. By analyzing patterns in the player's behavior, such as frequent attacks or healing, the enemy will adapt its strategy accordingly. For example, if the player consistently attacks, the enemy might predict this and choose to defend first and counterattack in response. If the enemy predicts that the player will use health potions, then it will attack the player with maximum power. 
%----------short version-------------
The game will employ a simple classification model, such as Naive Bayes, to predict the player's next action—whether to attack or use health potions to heal—based on the player’s previous decisions. By analyzing patterns in the player's behavior, such as frequent attacks or healing, the enemy will adapt its strategy accordingly. For example, if the player consistently attacks, the enemy might predict this and choose to defend first and counterattack in response. If the enemy predicts that the player will use health potions, then it will attack the player with maximum power. 

%---------DOCUMENTATION-------------------
%\noindent \textit{Documentation:} 
%------------------------------------
%After running and successfully compiling your program, ensure it works as described in the project requirements. Then, at the beginning of your code, include a comment with your name and a brief description of the program’s purpose. Throughout the code, add meaningful comments to explain the functionality of each class, method, and important sections of the code. Comments should clarify the purpose of the logic, the role of variables, and any complex or non-obvious code segments, making it easier for others to understand your implementation. Proper documentation will improve code readability and maintainability.
%-----------short version------------
%After compiling and verifying your program works as intended, include a comment at the top with your name and a short summary of the program’s purpose. Add clear, meaningful comments throughout the code to explain each class, method, and key logic. Your comments should describe the role of variables and clarify any complex or non-obvious code. Well-documented code improves readability and helps others understand your design.

%------------SUBMISSION------------------
%\noindent\textit{Submission:} Submit the following files: 
%----------------------------------
% \begin{enumerate}[label=(\roman*)]
% \item all relevant (.java) files used in the project, 
% \item a screenshot or file of the UML diagram generated showing the relationships and structure of the classes, 
% \item a screenshot or file of the program in action, demonstrating that the game runs as expected.
% \end{enumerate}
%------------short version------------
%(i) all relevant (.java) files used in the project; (ii) a screenshot or file of the UML diagram generated showing the relationships and structure of the classes; (iii) a screenshot or file of the program in action, demonstrating that the game runs as expected.
%------------------------------------
%\textit{Requirements and Resources:}
%For integrating the AI features, you may use the provided code. 